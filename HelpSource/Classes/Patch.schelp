CLASS:: Patch
summary:: Pairs an Instr with inputs that that will be passed to the Instr
categories:: Libraries>crucial>Instr, Libraries>crucial>Players
related:: Classes/Instr

DESCRIPTION:: A Patch is a player that plays an Instr.

An Instr (Instrument) is a named function.

A Patch specifies an Instr and the inputs that will be passed to the Instr function.

Note that an Instr can also be connected with other things using link::Classes/Mx:: and SynthDefs can be made from Instr in other ways than using Patch.

code::
(
// given a simple instrument
Instr(\Pulse,{ arg freq=440.0,width=0.5,mul=0.1;
	Pulse.ar( freq, width, mul )
});

// a patch specifies inputs (arguments) to that instrument
p = Patch( \Pulse, [ 300, 0.2, 0.1 ]);

//the default server will be booted, the SynthDef written and loaded
p.play;

)

p.stop;
::

Patch can also express arguments using argName:value dicts:

code::
p = Patch( \Pulse, (freq: 300) );
::


### Guides

list::
## link::Guides/Patch-inputs::
## link::Guides/Patch-Busses-and-Groups::
## link::Guides/Patch-spawning-and-patterns::
## link::Guides/Patch-client-server-magic::
::

CLASSMETHODS::

METHOD:: new


argument:: instr
The Instr can be specified as:

an Instr name
code::
(
	// given that an Instr is defined by name:
	Instr(\bubbles, { arg amp=1.0;
		var f, zout;
		f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8,7.23], 0, 3, 80)).midicps;
		zout = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4);
		zout * amp
	});

	// the patch retrieves it by name
	p = Patch(\bubbles,[0.4] );
	p.gui
)
::

a direct function that will be used to create an Instr in place
code::
(
	p = Patch({ arg freq=100,amp=1.0;
		SinOsc.ar([freq,freq + 30],0,amp)
	},[
		500,
		0.3
	]);
	p.gui
)
::

or directly pass an Instr object
code::
(
	i = Instr("help-Patch",{ arg freq=100,amp=1.0;
			SinOsc.ar([freq,freq + 30],0,amp)
		});
	p = Patch(i,[ 500,	0.3 ]);
	p.gui
)
::



argument:: inputs
an array of arguments for the Instr function.

Can also be a dictionary:  (argName: value, ... )

code::
Patch({ arg freq,amp;

	SinOsc.ar(freq,amp)
},(
	amp: 0.4
)).gui
::

argument:: outClass

default is Out.ar You could supply ReplaceOut to do effect processing on a Bus

returns::


INSTANCEMETHODS::

METHOD:: instr


argument:: newInstr


returns::

METHOD:: args


argument:: inputs


returns::

METHOD:: argsForSynth


returns::

METHOD:: argNamesForSynth


returns::

METHOD:: synthArgsIndices


returns::

METHOD:: synthDef


returns::

METHOD:: outClass


returns::

METHOD:: respawnOnChange


returns::

METHOD:: stepChildren


returns::

METHOD:: inputs


returns::

METHOD:: setInput


argument:: index


argument:: newArg


returns::

METHOD:: set


argument:: index


argument:: value


returns::

METHOD:: rand


argument:: standardDeviation


returns::

METHOD:: doesNotUnderstand


argument:: selector


argument::  ... dnuargs


returns::

METHOD:: argNames


returns::

METHOD:: argNameAt


argument:: i


returns::

METHOD:: specAt


argument:: i


returns::

METHOD:: spec


returns::

METHOD:: rate


returns::

METHOD:: numChannels


returns::

METHOD:: indexFromName


argument:: argName


returns::

METHOD:: argFromName


argument:: argName


returns::

METHOD:: loadSubject


argument:: name


returns::

METHOD:: createArgs


argument:: argargs


returns::

METHOD:: defName


returns::

METHOD:: asSynthDef


returns::

METHOD:: watchNoncontrols


returns::

METHOD:: respawn


argument:: atTime


returns::

METHOD:: update


argument:: changed


argument:: what


returns::

METHOD:: removeSynthDefCache


returns::

METHOD:: invalidateSynthDef


returns::

METHOD:: releaseArgs


returns::

METHOD:: didFree


returns::

METHOD:: prepareChildrenToBundle


argument:: bundle


returns::

METHOD:: spawnToBundle


argument:: bundle


returns::

METHOD:: didSpawn


returns::

METHOD:: synthDefArgs


returns::

METHOD:: stopToBundle


argument:: bundle


returns::

METHOD:: value


argument::  ... overideArgs


returns::

METHOD:: valueArray


argument:: overideArgs


returns::

METHOD:: asEvent


returns::

METHOD:: embedInStream


argument:: event


returns::

METHOD:: children


returns::

METHOD:: printOn


argument:: s


returns::

METHOD:: storeParamsOn


argument:: stream


returns::

METHOD:: storeArgs


returns::

METHOD:: guiClass


returns::

METHOD:: state


argument:: state


returns::

METHOD:: hasAudioInput


returns::

METHOD:: busReport


argument:: f


argument:: slogan


returns::




EXAMPLES::

Patch inside a patch

code::
Instr(\bubbles, { arg amp=1.0;
	var f, zout;
	f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8,7.23], 0, 3, 80)).midicps;
	zout = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4);
	zout * amp
});

Instr(\rlpf,{ arg audio=0,freq=500,rq=0.1;
	RLPF.ar(audio, freq, rq)
});

p = Patch(\rlpf,[
	q = Patch(\bubbles)
]);

p.gui
::


