title:: Instr SynthDefs
summary:: How Instr make SynthDefs
categories:: Libraries>crucial>Instr


section:: An Instr is not a SynthDef

link::blah::

An Instr can create an InstrSynthDef which is a subclass of SynthDef.

Each argument in the function for a SynthDef creates a Control input to the Synth that will eventually play on the server.

An Instr can also include extra arguments that will be used in building the synth def, but will not be Control inputs in the final synth.

For instance an Integer may be passed in:

code::
// caution: mind the feedback. AudioIn
(
Instr(\qAllpassA,{	arg audio,decay=1,maxDelay=0.3,quantity=4,chanDiff=0.1;

	(quantity.asInteger).do({
			var x;
			audio =
 				AllpassL.ar(audio, maxDelay,
 				[rrand(0.01,maxDelay),rrand(0.01,maxDelay)],
 				decay)
 		});
	audio
});

Patch(\qAllpassA,[
	{ AudioIn.ar([1,2]) },
	1,
	0.3,
	8
]).play

)
::

The first input to the synth is a stereo audio rate input, the others were fixed floats that did not require synth inputs.

Envelopes, fixed floats, fixed integers, Samples etc. can be passed into Instr functions.

When Patch is used to specify the inputs to the function some of these inputs will be reduced to fixed values (integers, floats, Envelopes etc.), and the resulting SynthDef will contain those inputs hard-coded.  Using different Patches, it is possible to write many SynthDefs from the same Instr.

code::
	Instr(\rlpf,{ arg input,ffreq=400,rq=0.1;
		RLPF.ar( input, ffreq, rq )
	});
::


	If the input supplied is stereo, the synthDef produced will be stereo.

code::
(
	Patch(\rlpf,[
		Patch({ Saw.ar([400,440],0.1) }) // in stereo
	]).play
)
::

It is possible to play another Instr inside of your Instr:

code::
(
	Instr(\sawfilter,{ arg freq,ffreq,rq;
		Instr.ar(\rlpf, [ Saw.ar(freq,0.1) , ffreq, rq ])
	})
)
::

and thus get further reuse out of your library of functions.  Here the \rlpf that is used inside doesn't produce a synth def, but is used as a simple function in the ugenGraph of the \sawfilter Instr which does make a synthDef.

It is not generally possible to use the .ar method on a player inside of an Instrument function.  This was possible in sc2.   You cannot use a sound file player in this way:

	sfp = SFP("path/to/soundfile");
	Instr('no-can-do',{ arg sfp,amp=1.0;
		sfp.ar * amp
	});

Because an SFP (soundfile player) will require a buffer, a bus, and various stages of preparation.  It is a complex process that cannot be compiled into a SynthDef.

the better approach is to use Patch which will manage the preparation process:

code::
	Instr("can-do",{ arg input,amp=1.0;
	  input * amp
	});

	Patch("can-do",[
		SFP("path/to/soundfile")
	])
::




SECTION:: Dynamic SynthDef architecture

You can design Instr to take parameters that are used only in the building of the SynthDef. This can be used to select from different kinds of filters or to build a mini-modular synth.

code::
Instr(\upOrDown, {arg upDown=0;
	var line;
	if (upDown>0,
		{line = Line.kr(1,0,5)}, // upDown>0 ==> pitch goes up
		{line = Line.kr(0,1,5)}  // upDown 0 or less ==> pitch goes down
	);
	SinOsc.ar(440*line,0,0.2);
},[
	StaticIntegerSpec(0,1)
]);

Patch(\upOrDown, [ 0]).play
::

The upDown param acts as a switch between different synth def architectures.  If your Instr library is well designed you can acheive very sophisticated sound structures with automatic optimizations and code reuse.

Note that the Patch would assume upDown to be a modulatable control input (with a default of 0.0) without the StaticIntegerSpec making it clear that its a static integer.





SECTION:: Function composition and partial application


code::
f = Instr("eperc",{ arg audio,dur=2.0; audio * EnvGen.kr(Env.sine(dur)) });

t = Instr("tonez",{ arg freq=300; Saw.ar(freq) });

// this creates a link::CompositeInstr::
// t is plugged into f
o = t <>> f;

o.gui;

Patch(o).rand.gui
::

If you create a link::Classes/CompositeInstr:: directly (without using <>> ) then you can specify which input on the second Instr to plug into.





METHOD:: papply


argument::  ... args


returns::
